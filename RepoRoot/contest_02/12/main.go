package main

import "fmt"

//  принимает двумерный слайс maze и определяет количество строк и столбцов в нем
func fill(maze [][]int) {
	rows := len(maze)
	cols := len(maze[0])

	for i := 0; i < rows; i++ {  // перебираем все ячейки
		for j := 0; j < cols; j++ {
			if maze[i][j] == -1 {
				continue // Пропускаем заминированные ячейки, так как в нее не нужно записывать количество мин в соседних ячейках.
			}
			
			// Для каждой не заминированной ячейки функция проверяет ее восемь соседних ячеек (включая диагональные). 
			// Если какая-то из соседних ячеек содержит мину, то счетчик count увеличивается.
			count := 0
			for x := -1; x <= 1; x++ {
				for y := -1; y <= 1; y++ {
					if x == 0 && y == 0 {
						continue // Пропускаем текущую ячейку
					}
					if i+x >= 0 && i+x < rows && j+y >= 0 && j+y < cols && maze[i+x][j+y] == -1 {
						count++ // Увеличиваем счетчик мин в соседних ячейках
					}
				}
			}
			// После того как для текущей ячейки посчитано количество мин в соседних ячейках,
			// это значение записывается обратно в срез maze.
			maze[i][j] = count // Записываем количество мин в текущую ячейку
		}
	}
}

func main() {
	var rows, cols int
	fmt.Scanf("%d %d\n", &rows, &cols)

	// Создаём срез и заполняем его данными о расположении мин
	maze := make([][]int, rows, rows)
	for i := range maze {
		maze[i] = make([]int, cols, cols)
		for j := range maze[i] {
			fmt.Scanf("%d", &maze[i][j])
		}
	}

	// Заполняем игровое поле подсказками
	fill(maze)

	// Выводим на экран
	for _, row := range maze {
		for _, cell := range row {
			fmt.Printf("%3d", cell)
		}
		fmt.Println()
	}
}

